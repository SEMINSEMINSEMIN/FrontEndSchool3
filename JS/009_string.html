<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        // string, 문자열
        let txt = "ABCDEFGHIJK";
        let txt2 = "mom said 'hello world'";
        // 이스케이프 문자
        let txt3 = "mom said \"hello world\"";
        let txt4 = "a\nb\ncde";
        let txt5 = "a\tbcde";
        let txt6 = "10abc";
        let txt7 = "10.1abc"; // parseFloat
        console.log(txt + txt);
        console.log(txt[0]);
        console.log(txt[4] + txt[5] + txt[6]);
        console.log(txt2);
        console.log(txt3);
        console.log(txt4);
        console.log(txt5);
        console.log(txt6 + txt6);
        // 숫자로 형변환시 parseInt 대신 Number를 써야하는 이유
        // Number의 안정성이 떨어짐: 결제금액 NaN으로 해서 이상한 짓하기....
        /* 
        parseInt : 숫자와 문자가 포함된 문자열 "2022년도" 에서 숫자부분만 뽑아냄 (소수점 포함 x)
        Number : 숫자만 있는 문자열에서 소수점 포함 숫자부분을 뽑아냄
        */
        console.log(parseInt(txt6) + parseInt(txt6));
        console.log(Number(txt6) + Number(txt6)); // NaN

        console.log(typeof txt);
        // console.dir(txt);

        console.log(parseFloat(txt7)); // 10.1
        console.log(parseInt(txt7)); // 10
        console.log(Number(txt7)); // NaN

        // 스트링의 메서드
        console.log(txt.length);
        // 11개의 글자지만, index는 length - 1

        // 둘 다 위치 반환
        // indexOf은 정규표현식을 허용하지 않음

        console.log(txt.indexOf("E"));
        console.log(txt.search("E"));

        // 존재하지 않는 값시 -1
        // 로직에 문제가 있음
        // -1은 true
        // if (txt.indexOf("Z") == -1) {} -> 못 발견했으면 뭘 해라
        console.log(txt.indexOf("Z")); // -1
        console.log(txt.search("Z")); // -1
        console.log(txt.indexOf("K")); // 10

        let regExp = /CD/;
        console.log(txt.search(regExp));

        let txt8 = "abcAHelloBC";
        // let txt9 = "paullab CEO leehojun CEO";
        // g: global
        // gm: global multiline
        let regExp8 = /[A-Z]/g;
        console.log(txt.search(regExp));
        

        // 현업에서 자주 사용하는거
        // slice(시작인덱스, 종료 인덱스): 시작인덱스부터 종료인덱스-1까지
        // substr (시작위치, 길이) : 시작인덱스부터 길이만큼 반환, 실무에서 잘 사용 x substring, slice 사용 권장
        let txt9 = "paullab CEO leehojun CEO";
        console.log(txt9.slice(0, 7));
        console.log(txt9.slice(0, 8)); // 공백도 문자다
        console.log(txt9.slice(1, 3));
        console.log(txt9.slice(3, 1)); // 작동 x
        console.log(txt9.slice(2));

        // substring(시작인덱스, 종료인덱스) : 시작인덱스부터 종료인덱스 -1까지
        // 인덱스 시작값이 길이보다 크면 순서를 바꿔버림
        console.log(txt9.substring(1, 3));
        console.log(txt9.substring(3, 1)); // 작동 o
        console.log(txt9.substring(2));

        console.log(txt9.substr(8, 3));
        console.log(txt9.substr(txt9.indexOf("C"), 3));

        // console.log(txt9.replace("CEO", "CTO"));
        // console.log(txt9.replace(/"CEO"/g, "CTO"));
        console.log(txt9.replace(/CEO/g, "CTO"));

        console.log(txt.toUpperCase());
        console.log(txt.toLowerCase());

        // indexOf의 단점(첫번째 문자가 0으로 반환되는 문제, 없는 문자가 -1로 반환되는 문제) 해결
        console.log(txt.includes("H")); // true
        console.log(txt.includes("Z")); // false

        // split
        console.log(txt9.split(' '));
        console.log('010-5044-2903'.split("-"));
        console.log('010-5044-2903'.split("")); // 실무

        // trim: 앞뒤로 공백을 없앰
        console.log("          abc");
        console.log("          abc".trim());
        // 중간에 있는 공백은 사라지지 않음
        console.log("          a b c".trim());
    </script>
</body>
</html>